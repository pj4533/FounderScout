#!/usr/bin/env python3
"""
Builder Scout - Discover overlooked prolific builders from overlooked projects.

This tool combines Project Scout's ability to find overlooked projects with
builder activity analysis. It:
1. Finds overlooked projects on HN and GitHub (like Project Scout)
2. Extracts the builders/owners of those projects
3. Analyzes their overall GitHub activity
4. Detects AI-assisted development patterns
5. Scores builders based on prolificness while being overlooked
"""

import argparse
import asyncio
import json
import os
import re
import sys
from collections import defaultdict
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field, asdict

import aiohttp
import requests
from dotenv import load_dotenv
from openai import OpenAI
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich import box
from rich.text import Text

# Load environment variables
load_dotenv()

console = Console()

# API endpoints
HN_BASE_URL = "https://hacker-news.firebaseio.com/v0"
GITHUB_BASE_URL = "https://api.github.com"

@dataclass
class Builder:
    """Represents a builder with their GitHub activity."""
    github_username: str
    github_profile: Optional[Dict] = None
    discovered_projects: List[Dict] = field(default_factory=list)  # Projects that led us to them
    all_repos: List[Dict] = field(default_factory=list)
    recent_commits: List[Dict] = field(default_factory=list)
    activity_stats: Dict = field(default_factory=dict)
    ai_usage_signals: List[str] = field(default_factory=list)
    ai_tools_used: Dict[str, int] = field(default_factory=dict)  # Tool name -> count
    score: float = 0.0
    score_breakdown: Dict = field(default_factory=dict)
    keywords: List[str] = field(default_factory=list)
    summary: str = ""
    vibe: str = ""
    
    def to_dict(self):
        """Convert to dictionary for JSON serialization."""
        return asdict(self)


class BuilderScout:
    """Discovers overlooked prolific builders from overlooked projects."""
    
    # AI tool patterns with their display names
    AI_PATTERNS = [
        (r"generated with.*claude", "Claude Code"),
        (r"co-authored-by.*claude", "Claude"),
        (r"claude code", "Claude Code"),
        (r"generated with.*copilot", "GitHub Copilot"),
        (r"co-authored-by.*copilot", "GitHub Copilot"),
        (r"generated with.*cursor", "Cursor"),
        (r"cursor ai", "Cursor"),
        (r"generated with.*chatgpt", "ChatGPT"),
        (r"generated with.*gpt", "GPT"),
        (r"generated with.*codeium", "Codeium"),
        (r"generated with.*tabnine", "Tabnine"),
        (r"generated with.*amazon.*q", "Amazon Q"),
        (r"generated with.*bard", "Google Bard"),
        (r"generated with.*gemini", "Google Gemini"),
        (r"ai.assisted", "AI"),
        (r"ai-generated", "AI"),
        (r"generated by ai", "AI"),
        (r"written with ai", "AI"),
        (r"ðŸ¤–", "AI"),
    ]
    
    def __init__(self, days: int = 7, top: int = 20, no_llm: bool = False, verbose: bool = False):
        self.days = days
        self.top = top
        self.no_llm = no_llm
        self.verbose = verbose
        self.github_token = os.getenv('GITHUB_TOKEN')
        self.github_headers = {
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'BuilderScout/1.0'
        }
        if self.github_token:
            self.github_headers['Authorization'] = f'token {self.github_token}'
        else:
            console.print("[yellow]Note: No GitHub token found. Results will be limited. Set GITHUB_TOKEN in .env file.[/yellow]")
        
        # Initialize OpenAI client if needed
        if not self.no_llm:
            api_key = os.getenv('OPENAI_API_KEY')
            if api_key:
                self.openai_client = OpenAI(api_key=api_key)
                self.model = os.getenv('OPENAI_MODEL', 'gpt-4o-mini')
            else:
                console.print("[yellow]Warning: No OpenAI API key found. Skipping LLM enrichment.[/yellow]")
                self.no_llm = True
    
    async def fetch_hn_item(self, session: aiohttp.ClientSession, item_id: int) -> Optional[Dict]:
        """Fetch a single HN item."""
        url = f"{HN_BASE_URL}/item/{item_id}.json"
        try:
            async with session.get(url) as response:
                if response.status == 200:
                    return await response.json()
        except Exception as e:
            if self.verbose:
                console.print(f"[red]Error fetching HN item {item_id}: {e}[/red]")
        return None
    
    async def find_overlooked_projects(self) -> Dict[str, List[Dict]]:
        """Find overlooked projects from HN and GitHub (similar to Project Scout)."""
        builder_to_projects = defaultdict(list)
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            
            # Part 1: Scan HN for overlooked projects
            task = progress.add_task("Scanning HN for overlooked projects...", total=None)
            
            async with aiohttp.ClientSession() as session:
                # Get Show HN, Ask HN, and new stories
                story_types = ['showstories', 'askstories', 'newstories']
                all_item_ids = set()
                
                for story_type in story_types:
                    url = f"{HN_BASE_URL}/{story_type}.json"
                    try:
                        async with session.get(url) as response:
                            if response.status == 200:
                                item_ids = await response.json()
                                all_item_ids.update(item_ids[:200])
                    except Exception as e:
                        if self.verbose:
                            console.print(f"[red]Error fetching {story_type}: {e}[/red]")
                
                # Fetch items
                items = await asyncio.gather(
                    *[self.fetch_hn_item(session, item_id) for item_id in all_item_ids]
                )
                
                # Filter for overlooked posts with GitHub links
                cutoff_time = datetime.now(timezone.utc) - timedelta(days=self.days)
                cutoff_timestamp = cutoff_time.timestamp()
                github_pattern = r'github\.com/([a-zA-Z0-9](?:[a-zA-Z0-9]|-(?=[a-zA-Z0-9])){0,38})'
                
                for item in items:
                    if not item or item.get('time', 0) < cutoff_timestamp:
                        continue
                    
                    if item.get('type') != 'story':
                        continue
                    
                    text = item.get('text', '')
                    title = item.get('title', '')
                    url = item.get('url', '')
                    points = item.get('score', 0)
                    comments = item.get('descendants', 0)
                    
                    # Calculate passion vs engagement (from Project Scout logic)
                    passion_score = len(text) / 100 if text else 0
                    engagement_score = (points + comments * 2) / 10
                    
                    # Look for overlooked posts (high passion, low engagement)
                    is_overlooked = False
                    if passion_score > 1 and engagement_score < 10:
                        is_overlooked = True
                    elif points < 30 and 'Show HN' in title:
                        is_overlooked = True
                    elif points < 20 and text and len(text) > 100:
                        is_overlooked = True
                    
                    if is_overlooked:
                        # Extract GitHub usernames
                        full_text = f"{text} {title} {url}"
                        matches = re.findall(github_pattern, full_text, re.IGNORECASE)
                        for username in matches:
                            if username not in ['sponsors', 'settings', 'notifications', 'explore']:
                                project = {
                                    'source': 'hn',
                                    'title': title,
                                    'url': url,
                                    'points': points,
                                    'comments': comments,
                                    'passion_score': passion_score,
                                    'time': item.get('time')  # Unix timestamp
                                }
                                builder_to_projects[username].append(project)
            
            # Part 2: Scan GitHub for overlooked projects
            progress.update(task, description="Scanning GitHub for overlooked projects...")
            
            date_filter = (datetime.now() - timedelta(days=self.days)).strftime('%Y-%m-%d')
            
            # Queries focused on overlooked but substantial projects
            queries = [
                f"created:>{date_filter} stars:<10",  # New with no traction
                f"pushed:>{date_filter} stars:<30 size:>1000",  # Active, substantial, overlooked
                f"created:>{date_filter} stars:0..5 size:>500",  # Brand new substantial projects
            ]
            
            seen_repos = set()
            
            for query in queries:
                try:
                    response = requests.get(
                        f"{GITHUB_BASE_URL}/search/repositories",
                        params={
                            'q': query,
                            'sort': 'updated',
                            'order': 'desc',
                            'per_page': 50
                        },
                        headers=self.github_headers,
                        timeout=5
                    )
                    
                    if response.ok:
                        data = response.json()
                        for repo in data.get('items', []):
                            repo_id = repo.get('id')
                            if repo_id in seen_repos:
                                continue
                            seen_repos.add(repo_id)
                            
                            # Check if it's substantial
                            description = (repo.get('description') or '')
                            if len(description) > 20 and repo.get('size', 0) > 100:
                                owner = repo.get('owner', {}).get('login')
                                if owner:
                                    project = {
                                        'source': 'github',
                                        'name': repo.get('name'),
                                        'description': description,
                                        'url': repo.get('html_url'),
                                        'stars': repo.get('stargazers_count', 0),
                                        'language': repo.get('language'),
                                        'size': repo.get('size', 0),
                                        'created_at': repo.get('created_at')  # ISO format datetime
                                    }
                                    builder_to_projects[owner].append(project)
                                    
                except Exception as e:
                    if self.verbose:
                        console.print(f"[yellow]GitHub search error: {e}[/yellow]")
        
        return builder_to_projects
    
    def fetch_github_user(self, username: str) -> Optional[Dict]:
        """Fetch GitHub user profile."""
        url = f"{GITHUB_BASE_URL}/users/{username}"
        try:
            response = requests.get(url, headers=self.github_headers, timeout=3)
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return None
    
    def analyze_builder_activity(self, builders: Dict[str, Builder]) -> None:
        """Analyze GitHub activity for each builder."""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            task = progress.add_task("Analyzing builder activity...", total=len(builders))
            
            for username, builder in builders.items():
                progress.update(task, advance=1)
                
                # Fetch all repos
                repos_url = f"{GITHUB_BASE_URL}/users/{username}/repos"
                params = {'sort': 'updated', 'per_page': 100}
                try:
                    response = requests.get(repos_url, headers=self.github_headers, params=params, timeout=3)
                    if response.status_code == 200:
                        builder.all_repos = response.json()
                except:
                    pass
                
                # Fetch recent activity
                events_url = f"{GITHUB_BASE_URL}/users/{username}/events/public"
                params = {'per_page': 100}
                try:
                    response = requests.get(events_url, headers=self.github_headers, params=params, timeout=3)
                    if response.status_code == 200:
                        events = response.json()
                        
                        activity_counts = defaultdict(int)
                        recent_commits = []
                        
                        for event in events:
                            event_type = event.get('type', '')
                            activity_counts[event_type] += 1
                            
                            # Extract commits
                            if event_type == 'PushEvent':
                                commits = event.get('payload', {}).get('commits', [])
                                for commit in commits:
                                    commit['repo'] = event.get('repo', {}).get('name', '')
                                    recent_commits.append(commit)
                        
                        builder.recent_commits = recent_commits[:100]
                        builder.activity_stats = dict(activity_counts)
                        
                        # Detect AI usage
                        self.detect_ai_usage(builder)
                except:
                    pass
    
    def detect_ai_usage(self, builder: Builder) -> None:
        """Detect AI usage patterns in commit messages and track specific tools."""
        ai_commits = []
        tool_counts = defaultdict(int)
        
        for commit in builder.recent_commits:
            message = commit.get('message', '').lower()
            for pattern, tool_name in self.AI_PATTERNS:
                if re.search(pattern, message, re.IGNORECASE):
                    ai_commits.append(commit['message'][:100])
                    tool_counts[tool_name] += 1
                    break
        
        builder.ai_usage_signals = ai_commits
        builder.ai_tools_used = dict(tool_counts)
    
    def score_builders(self, builders: Dict[str, Builder]) -> List[Builder]:
        """Score builders based on being prolific yet overlooked."""
        scored_builders = []
        
        for username, builder in builders.items():
            breakdown = {
                'prolificness': 0,
                'overlooked_factor': 0,
                'ai_adoption': 0,
                'consistency': 0,
                'project_quality': 0
            }
            
            # Prolificness score (0-30)
            if builder.activity_stats:
                push_events = builder.activity_stats.get('PushEvent', 0)
                create_events = builder.activity_stats.get('CreateEvent', 0)
                pr_events = builder.activity_stats.get('PullRequestEvent', 0)
                
                prolific_score = min(30, 
                    push_events * 1.5 +    # Commits
                    create_events * 10 +   # New projects
                    pr_events * 2          # Contributions
                )
                breakdown['prolificness'] = prolific_score
            
            # Overlooked factor (0-30) - many repos but low stars
            if builder.all_repos:
                total_stars = sum(repo.get('stargazers_count', 0) for repo in builder.all_repos)
                active_repos = sum(1 for repo in builder.all_repos 
                                 if (datetime.now(timezone.utc) - 
                                     datetime.fromisoformat(repo.get('updated_at', '2000-01-01').replace('Z', '+00:00'))).days < 90)
                
                if active_repos > 0:
                    avg_stars = total_stars / active_repos
                    if avg_stars < 10 and active_repos > 2:
                        overlooked_score = min(30, active_repos * 5)
                    elif avg_stars < 30 and active_repos > 1:
                        overlooked_score = min(20, active_repos * 3)
                    else:
                        overlooked_score = 0
                    breakdown['overlooked_factor'] = overlooked_score
            
            # AI adoption (0-20)
            if builder.ai_usage_signals:
                ai_score = min(20, len(builder.ai_usage_signals) * 4)
                breakdown['ai_adoption'] = ai_score
            
            # Consistency (0-10)
            if builder.recent_commits:
                unique_days = len(set(c.get('sha', '')[:7] for c in builder.recent_commits[:30]))
                consistency_score = min(10, unique_days / 2)
                breakdown['consistency'] = consistency_score
            
            # Project quality from discovered projects (0-10)
            if builder.discovered_projects:
                quality_score = 0
                for project in builder.discovered_projects:
                    if project['source'] == 'hn':
                        # Higher passion score = higher quality
                        quality_score += min(5, project.get('passion_score', 0))
                    else:  # github
                        # Larger size = more substantial
                        size = project.get('size', 0)
                        quality_score += min(5, size / 1000)
                breakdown['project_quality'] = min(10, quality_score)
            
            builder.score = sum(breakdown.values())
            builder.score_breakdown = breakdown
            
            if builder.score > 20:  # Minimum threshold
                scored_builders.append(builder)
        
        scored_builders.sort(key=lambda x: x.score, reverse=True)
        return scored_builders[:self.top]
    
    def enrich_with_llm(self, builders: List[Builder]) -> None:
        """Enrich builder profiles with LLM insights."""
        if self.no_llm or not builders:
            return
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            task = progress.add_task("Enriching profiles with AI...", total=None)
            
            builders_data = []
            for builder in builders:
                context = {
                    'github_username': builder.github_username,
                    'recent_repos': [
                        {'name': r.get('name'), 'description': r.get('description', ''), 
                         'language': r.get('language')} 
                        for r in builder.all_repos[:5]
                    ],
                    'activity_stats': builder.activity_stats,
                    'ai_usage': bool(builder.ai_usage_signals),
                    'discovered_from': [p.get('title', p.get('name', '')) for p in builder.discovered_projects[:3]]
                }
                builders_data.append(context)
            
            prompt = f"""Analyze these {len(builders)} overlooked but prolific builders and for each provide:
1. Keywords: 3-5 technical skills/domains
2. Summary: 1-2 sentences about what makes them interesting as a builder
3. Vibe: One word (innovative/experimental/methodical/versatile/passionate)

Builders:
{json.dumps(builders_data, indent=2)}

Return JSON array with: index, keywords (array), summary (string), vibe (string)"""
            
            try:
                response = self.openai_client.chat.completions.create(
                    model=self.model,
                    messages=[
                        {"role": "system", "content": "You analyze developer profiles."},
                        {"role": "user", "content": prompt}
                    ],
                    response_format={"type": "json_object"}
                )
                
                result = json.loads(response.choices[0].message.content)
                enrichments = result.get('builders', result.get('results', []))
                
                for enrichment in enrichments:
                    idx = enrichment.get('index', 0)
                    if idx < len(builders):
                        builders[idx].keywords = enrichment.get('keywords', [])
                        builders[idx].summary = enrichment.get('summary', '')
                        builders[idx].vibe = enrichment.get('vibe', '')
                
            except Exception as e:
                console.print(f"[yellow]LLM enrichment error: {e}[/yellow]")
    
    def display_builders(self, builders: List[Builder], output_format: str = 'card') -> None:
        """Display builders in card or JSON format."""
        if output_format == 'json':
            output = {
                'metadata': {
                    'generated_at': datetime.now().isoformat(),
                    'days_back': self.days,
                    'total_builders': len(builders)
                },
                'builders': [b.to_dict() for b in builders]
            }
            console.print(json.dumps(output, indent=2))
            return
        
        if output_format == 'compact':
            self.display_compact(builders)
        else:
            self.display_cards(builders)
    
    def display_compact(self, builders: List[Builder]) -> None:
        """Display in compact one-line format."""
        # Header
        console.print(f"\n[bold cyan]ðŸ”¨ Builder Scout - Overlooked Prolific Builders[/bold cyan]")
        console.print(f"[dim]Projects from last {self.days} days | Activity analyzed from recent GitHub events[/dim]\n")
        
        for i, builder in enumerate(builders, 1):
            username = builder.github_username
            name = builder.github_profile.get('name', '') if builder.github_profile else ''
            display_name = f"{name} (@{username})" if name else f"@{username}"
            
            # Activity summary
            repos = len(builder.all_repos)
            pushes = builder.activity_stats.get('PushEvent', 0)
            creates = builder.activity_stats.get('CreateEvent', 0)
            
            # Get most used AI tool
            ai = ""
            if builder.ai_tools_used:
                top_tool = max(builder.ai_tools_used.items(), key=lambda x: x[1])
                ai = f"{top_tool[0]}âœ“"
            
            score_color = "bright_magenta" if builder.score > 60 else "magenta"
            
            # One-line format
            console.print(f"{i:2}. [{score_color}]{builder.score:.1f}[/{score_color}] [bright_blue]{display_name:35}[/bright_blue] [green]{repos} repos, {pushes} pushes, {creates} new[/green] [yellow]{ai}[/yellow]")
        
        console.print(f"\n[dim]Higher scores = prolific builders with low recognition[/dim]")
    
    def display_cards(self, builders: List[Builder]) -> None:
        """Display in card format (default)."""
        # Header
        console.print(f"\n[bold cyan]ðŸ”¨ Builder Scout - Overlooked Prolific Builders[/bold cyan]")
        console.print(f"[dim]Analyzing projects from last {self.days} days | GitHub activity from recent events (up to 90 days)[/dim]")
        console.print(f"[dim]Found {len(builders)} builders from overlooked projects[/dim]\n")
        
        for i, builder in enumerate(builders, 1):
            # Rank and Score
            score_color = "bright_magenta" if builder.score > 60 else "magenta"
            console.print(f"[bold]{i}.[/bold] [bold {score_color}]Score: {builder.score:.1f}[/bold {score_color}]", end="  ")
            
            # AI badge with specific tool
            if builder.ai_tools_used:
                # Get the most used tool or show multiple if they use several
                if len(builder.ai_tools_used) == 1:
                    tool_name = list(builder.ai_tools_used.keys())[0]
                    console.print(f"[yellow][{tool_name}][/yellow]", end="  ")
                else:
                    # Show top 2 tools if using multiple
                    top_tools = sorted(builder.ai_tools_used.items(), key=lambda x: x[1], reverse=True)[:2]
                    tool_names = "/".join([t[0] for t in top_tools])
                    console.print(f"[yellow][{tool_names}][/yellow]", end="  ")
            
            console.print()  # New line after badges
            
            # Builder name and username
            if builder.github_profile and builder.github_profile.get('name'):
                console.print(f"   [bold green]{builder.github_profile['name']}[/bold green] ([bright_blue]@{builder.github_username}[/bright_blue])")
            else:
                console.print(f"   [bold bright_blue]@{builder.github_username}[/bold bright_blue]")
            
            # Bio if available
            if builder.github_profile and builder.github_profile.get('bio'):
                bio = builder.github_profile['bio'][:100]
                console.print(f"   [white]{bio}[/white]")
            
            # Activity summary with time context
            activity_parts = []
            if builder.all_repos:
                # Count repos updated in different time frames
                repos_30d = sum(1 for r in builder.all_repos 
                              if (datetime.now(timezone.utc) - 
                                  datetime.fromisoformat(r.get('updated_at', '2000-01-01').replace('Z', '+00:00'))).days < 30)
                repos_90d = sum(1 for r in builder.all_repos 
                              if (datetime.now(timezone.utc) - 
                                  datetime.fromisoformat(r.get('updated_at', '2000-01-01').replace('Z', '+00:00'))).days < 90)
                activity_parts.append(f"ðŸ“¦ {repos_30d} repos active (30d), {repos_90d} total active (90d)")
            
            if builder.activity_stats:
                pushes = builder.activity_stats.get('PushEvent', 0)
                creates = builder.activity_stats.get('CreateEvent', 0)
                prs = builder.activity_stats.get('PullRequestEvent', 0)
                if pushes:
                    activity_parts.append(f"ðŸ’¾ {pushes} push events")
                if creates:
                    activity_parts.append(f"âœ¨ {creates} new projects/branches")
                if prs:
                    activity_parts.append(f"ðŸ”€ {prs} PRs")
            
            if activity_parts:
                console.print(f"   [cyan]Recent Activity:[/cyan] {', '.join(activity_parts)}")
            
            # AI usage details with specific tools
            if builder.ai_tools_used:
                tool_summary = []
                for tool, count in sorted(builder.ai_tools_used.items(), key=lambda x: x[1], reverse=True):
                    tool_summary.append(f"{tool} ({count})")
                console.print(f"   [yellow]ðŸ¤– AI Usage:[/yellow] {', '.join(tool_summary)} - {len(builder.ai_usage_signals)} total AI-assisted commits")
            
            # LLM enrichment
            if not self.no_llm:
                if builder.summary:
                    console.print(f"   [italic]ðŸ’¡ {builder.summary}[/italic]")
                if builder.keywords:
                    console.print(f"   [cyan]Skills: {', '.join(builder.keywords)}[/cyan]")
                if builder.vibe:
                    console.print(f"   [magenta]Vibe: {builder.vibe}[/magenta]")
            
            # Discovery source with date
            if builder.discovered_projects:
                project = builder.discovered_projects[0]
                if project['source'] == 'hn':
                    # Convert Unix timestamp to date
                    timestamp = project.get('time')
                    if timestamp:
                        date = datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d')
                    else:
                        date = 'Unknown date'
                    source_text = f"HN post ({date}): {project.get('title', 'Unknown')}"
                else:
                    # Parse ISO format date
                    created_at = project.get('created_at')
                    if created_at:
                        date = datetime.fromisoformat(created_at.replace('Z', '+00:00')).strftime('%Y-%m-%d')
                    else:
                        date = 'Unknown date'
                    source_text = f"GitHub repo ({date}): {project.get('name', 'Unknown')}"
                console.print(f"   [dim]Discovered via: {source_text}[/dim]")
            
            # GitHub profile link
            console.print(f"   [dim]Profile: https://github.com/{builder.github_username}[/dim]")
            
            # Verbose details
            if self.verbose and builder.score_breakdown:
                console.print(f"   [dim]Score breakdown:", end="")
                score_parts = [f"{k.replace('_', ' ')}: {v:.0f}" for k, v in builder.score_breakdown.items() if v > 0]
                console.print(f" {' | '.join(score_parts)}[/dim]")
            
            # Separator between builders
            if i < len(builders):
                console.print()
        
        # Footer with summary
        console.print(f"\n[dim]ðŸ“Š Summary Statistics:[/dim]")
        ai_users = sum(1 for b in builders if b.ai_usage_signals)
        total_repos = sum(len(b.all_repos) for b in builders)
        total_pushes = sum(b.activity_stats.get('PushEvent', 0) for b in builders)
        
        # Collect all AI tools used
        all_tools = defaultdict(int)
        for b in builders:
            for tool, count in b.ai_tools_used.items():
                all_tools[tool] += 1
        
        console.print(f"[dim]  â€¢ {len(builders)} builders analyzed[/dim]")
        if builders:
            console.print(f"[dim]  â€¢ {ai_users}/{len(builders)} ({ai_users/len(builders)*100:.0f}%) using AI tools[/dim]")
            if all_tools:
                top_tools = sorted(all_tools.items(), key=lambda x: x[1], reverse=True)[:3]
                tool_str = ", ".join([f"{t[0]} ({t[1]} users)" for t in top_tools])
                console.print(f"[dim]  â€¢ Most popular AI tools: {tool_str}[/dim]")
        console.print(f"[dim]  â€¢ {total_repos} total repositories across all builders[/dim]")
        console.print(f"[dim]  â€¢ {total_pushes} total push events in recent activity[/dim]")
        console.print(f"\n[dim]Scoring: Prolificness (commits, new projects) Ã— Overlooked factor (low stars/forks)[/dim]")
        console.print(f"[dim]Higher scores = talented builders working on overlooked projects[/dim]")
    
    async def scout(self) -> List[Builder]:
        """Main scouting method."""
        console.print(f"\nðŸ” [bold cyan]Builder Scout[/bold cyan] - Finding overlooked prolific builders...\n")
        
        # Step 1: Find overlooked projects and their builders
        builder_to_projects = await self.find_overlooked_projects()
        console.print(f"âœ… Found {len(builder_to_projects)} potential builders from overlooked projects\n")
        
        if not builder_to_projects:
            return []
        
        # Step 2: Create Builder objects and fetch profiles
        builders = {}
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            task = progress.add_task("Fetching GitHub profiles...", total=len(builder_to_projects))
            
            # Limit to top N to avoid rate limits
            for username, projects in list(builder_to_projects.items())[:100]:
                progress.update(task, advance=1)
                
                # Skip common bot/org accounts
                if username.lower() in ['dependabot', 'github-actions', 'renovate']:
                    continue
                    
                profile = self.fetch_github_user(username)
                if profile:
                    # Check if it's a user (not org)
                    if profile.get('type') == 'User':
                        builder = Builder(github_username=username)
                        builder.github_profile = profile
                        builder.discovered_projects = projects
                        builders[username] = builder
                elif not self.github_token:
                    # Without token, assume it's a valid user if the name looks reasonable
                    if len(username) > 2 and not username.startswith('_'):
                        builder = Builder(github_username=username)
                        builder.discovered_projects = projects
                        builders[username] = builder
                        if len(builders) >= 20:  # Limit without API access
                            break
        
        console.print(f"âœ… Successfully fetched {len(builders)} builder profiles\n")
        
        if not builders:
            return []
        
        # Step 3: Analyze their GitHub activity
        self.analyze_builder_activity(builders)
        
        # Step 4: Score and rank
        top_builders = self.score_builders(builders)
        console.print(f"âœ… Scored and ranked top {len(top_builders)} builders\n")
        
        # Step 5: Enrich with LLM
        if not self.no_llm and top_builders:
            self.enrich_with_llm(top_builders)
            console.print("âœ… Enriched profiles with AI insights\n")
        
        return top_builders


def main():
    parser = argparse.ArgumentParser(
        description='Builder Scout - Discover overlooked prolific builders from overlooked projects'
    )
    parser.add_argument('--days', type=int, default=7,
                       help='Days to look back (default: 7)')
    parser.add_argument('--top', type=int, default=20,
                       help='Top builders to show (default: 20)')
    parser.add_argument('--no-llm', action='store_true',
                       help='Skip LLM enrichment')
    parser.add_argument('--verbose', action='store_true',
                       help='Show detailed information')
    parser.add_argument('--output', choices=['card', 'compact', 'json'], default='card',
                       help='Output format (default: card)')
    
    args = parser.parse_args()
    
    scout = BuilderScout(
        days=args.days,
        top=args.top,
        no_llm=args.no_llm,
        verbose=args.verbose
    )
    
    try:
        builders = asyncio.run(scout.scout())
        if builders:
            scout.display_builders(builders, args.output)
        else:
            console.print("[yellow]No builders found. Try increasing --days or check GitHub token.[/yellow]")
    except KeyboardInterrupt:
        console.print("\n[red]Interrupted[/red]")
        sys.exit(1)
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()